#[derive(Debug, Clone, clap::Parser)]
#[command(version, about, long_about = None)]
/// Rusty Jekyll
pub struct CliArgs {
	#[clap(subcommand)]
	pub command: HydeCommand,
}

#[derive(Debug, Clone, clap::Subcommand)]
pub enum HydeCommand {
	/// Generates shell completions for the CLI.
	/// 
	/// Either run `source <(hyde completions SHELL)` or add the same line to your shell's configuration file.
	Completion { shell: clap_complete::Shell },
	/// Build a Hyde site.
	/// 
	/// This command processes a Hyde project and writes the output to the target directory.
	Build(HydePathArgs),
	/// Serve a Hyde site.
	/// 
	/// This command processes a Hyde project and writes the output to the target directory.  
	/// It then serves the site as a local web server. The web server can be connected to locally
	/// and supports hot reloading.
	Serve(HydePathArgs),
	/// Cleans temporary data of a Hyde project.
	/// 
	/// This command removes all 'temporary' data generated by Hyde.
	/// This includes the output directory.
	Clean(HydePathArgs),
}

#[derive(Debug, Clone, clap::Parser)]
pub struct HydePathArgs {
	#[arg(short, long, env="HYDE_DIR")]
	/// The path of the project directory to process.
	/// If omitted, the current directory will be used.
	pub dir: Option<std::path::PathBuf>,

	#[arg(short, long, env="HYDE_OUT_DIR")]
	/// The path of the output directory to write to.
	/// The default for the project will be used if omitted.
	pub out: Option<std::path::PathBuf>,
}

pub fn generate_completion(shell: clap_complete::Shell) {
	clap_complete::generate(
		shell,
		&mut <CliArgs as clap::CommandFactory>::command(),
		std::env::current_exe()
			.ok()
			.and_then(|p| p.file_stem().and_then(std::ffi::OsStr::to_str).map(ToOwned::to_owned))
			.unwrap_or(env!("CARGO_BIN_NAME").to_string()),
		&mut std::io::stdout(),
	)
}

#[test]
pub fn verify_cmd() {
	use clap::CommandFactory;
	CliArgs::command().debug_assert();
}
