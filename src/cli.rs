#[derive(Debug, Clone, clap::Parser)]
#[command(version, about, long_about = None)]
/// Rusty Jekyll
pub struct CliArgs {
	#[clap(subcommand)]
	pub command: HydeCommand,
	#[clap(flatten)]
	pub path_args: HydePathArgs,
}

#[derive(Debug, Clone, clap::Subcommand)]
pub enum HydeCommand {
	/// Generates shell completions for the CLI.
	/// 
	/// Either run `source <(hyde completions SHELL)` or add the same line to your shell's configuration file.
	Completion { shell: clap_complete::Shell },
	
	/// Build a Hyde site.
	/// 
	/// This command processes a Hyde project and writes the output to the target directory.
	Build,

	/// Serve a Hyde site.
	/// 
	/// This command processes a Hyde project and writes the output to the target directory.  
	/// It then serves the site as a local web server. The web server can be connected to locally
	/// and supports hot reloading.
	Serve {
		#[arg(env="HYDE_PORT")]
		/// The port to serve the site on.
		/// The default is 4000.
		port: Option<u16>,
	},

	/// Cleans temporary data of a Hyde project.
	/// 
	/// This command removes all 'temporary' data generated by Hyde.
	/// This includes the output directory.
	Clean,
}

#[derive(Debug, Clone, clap::Args)]
pub struct HydePathArgs {
	#[arg(short, long, env="HYDE_DIR")]
	/// The path of the project directory to process.
	/// If omitted, the current directory will be used.
	pub dir: Option<std::path::PathBuf>,

	#[arg(short, long, env="HYDE_OUT_DIR")]
	/// The path of the output directory to write to.
	/// The default for the project will be used if omitted.
	pub out: Option<std::path::PathBuf>,
}

pub fn generate_completion(shell: clap_complete::Shell) {
	clap_complete::generate(
		shell,
		&mut <CliArgs as clap::CommandFactory>::command(),
		std::env::current_exe()
			.ok()
			.as_ref()
			.and_then(|p| p.file_name())
			.and_then(std::ffi::OsStr::to_str)
			.unwrap_or(env!("CARGO_BIN_NAME")),
		&mut std::io::stdout(),
	)
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	pub fn verify_cmd() {
		use clap::CommandFactory;
		CliArgs::command().debug_assert();
	}
}
